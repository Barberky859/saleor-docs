---
title: Restricting API access
sidebar_position: 2
---

Even though Saleor [implements complex authorization and authentication](/api-usage/authentication.mdx) mechanisms, you might want to restrict access to your Saleor Cloud instance for specific use cases.

Below, we explore two ways Saleor Cloud allows you to restrict access to the API, as well as a practical example of how to use one of them.

## Allowed API origins

Most times, the list of the origins you expect to call your API is known in advance. By specifying the allowed origins, you can prevent unauthorized access to your API.

In the project view of your Saleor Cloud dashboard, you can customize the allowed origins. The default option is to "Allow all", but you can also specify a list of origins or set it to "Dashboard only".

:::info

Changing the settings to only allow the selected origins can affect the installed apps. If you want your app to call the Saleor API from the client, you need to add the app's origin to the list of allowed origins. You can read more about app's access scopes in the [App permissions](developer/extending/apps/architecture/app-permissions.mdx#access-scopes) document.

:::

Here is how an example list of allowed origins may look:

- `https://your-storefront.com` - your storefront
- `https://your-app-1.com` - your first app (if it is calling the Saleor API from the client)
- `https://your-app-2.com` - your second app (if it is calling the Saleor API from the client)

You don't need to specify the Saleor Cloud dashboard origin, as it is always allowed to call the Saleor API.

## API Password Protection

Another way to restrict access to your Saleor Cloud instance is to protect it with a password through [Basic Auth](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#basic_authentication_scheme). This way, you can ensure that only those who know the credentials can access the API.

:::important

After enabling password protection, users trying to open the Saleor Dashboard will be prompted to enter the Basic Auth username and password, besides their own Saleor Cloud credentials.

:::

Combined with a server-side proxy, this can be a powerful tool to obscure the Saleor API from unauthorized access. We will explore this in more detail in the example below.

## Example: Password-protected API proxy

### Overview

Let's imagine you have a storefront that communicates with Saleor API. Your storefront, naturally, implements some sort of a checkout flow. In Saleor, most checkout actions don't require the user to be authenticated. It is done so by design - you want to allow users to manage their cart without being logged in.

After some time, you realize your checkout flow requires some custom logic. Normally, you would utilize either the synchronous (e.g., the [transaction events](/developer/extending/webhooks/synchronous-events/transaction.mdx) for payment processing) or asynchronous (e.g., the [checkout events](/api-reference/webhooks/enums/webhook-event-type-async-enum.mdx#code-style-fontweight-normal-webhookeventtypeasyncenumbcheckout_createdbcode)) webhooks. However, let's assume your use case doesn't fit into the webhooks model. You need to execute the logic "aside" from the Saleor checkout flow.

By introducing this custom piece of code, Saleor is no longer the source of truth for the checkout process. Given the open access to the [Checkout API](developer/checkout/overview.mdx), the user can just call the API directly and bypass your custom logic.

To prevent this, you can obstruct access to the Saleor API by protecting it with a password. You can then create a proxy server that will know the credentials and the address and thus, will be able to access the Saleor API. The only way to get to the Saleor API will be through the proxy server.

Here is how it may look in practice on the example of a simple Next.js application. At the moment, it calls the Saleor API directly:

### Implementation

#### Step 1: Protect the Saleor API with a password

Set up "API Password Protection" in the Saleor Cloud dashboard as [described above](#api-password-protection).

#### Step 2: Visit your current implementation

In the current implementation, your Next.js application calls the Saleor API directly:

:::note

In a production-grade Next.js application, you most likely would use some GraphQL client (like [Apollo Client](https://www.apollographql.com/docs/react/)) to fetch the data from the Saleor API. However, for the sake of simplicity, we will use the native `fetch` API in this example.

:::

```jsx
async function getProducts() {
  const response = await fetch("https://your-store.saleor.cloud/graphql", { // The URL of your Saleor instance
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      // The GraphQL query you want to execute
      query: `
          query GetProducts {
            products(first: 10) {
              edges {
                node {
                  id
                }
              }
            }
          }
      `,
    }),
  });

  const data = await response.json();

  // ...
}

const ProductList = () => {
    useEffect(() => {
        getProducts();
    }, []);

    return (
        // ...
    );
}
```

Our goal is to change the code above as little as possible when introducing the proxy server.

#### Step 3: Create a proxy API route

In most cases, you would call the Saleor GraphQL API straight from the React component. However, given that we want to obscure the Saleor API behind a basic auth, we can't just pass the credentials to the client. They would be easily accessible to anyone who inspects the code.

Instead, we will create a proxy API route that will know the credentials and the address of our GraphQL endpoint. As long as we don't expose the credentials to the client, we can ensure that our proxy server is the only one that can access the Saleor API directly.

What's more is that inside the API route, we can further execute the custom logic that we needed to introduce in the first place.

Here is how the proxy API route may look:

```jsx
// pages/api/saleor.js
export default async (req, res) => {
  const username = process.env.SALEOR_API_USERNAME; // Take the Basic Auth username from an environment variable
  const password = process.env.SALEOR_API_PASSWORD; // Take the Basic Auth password from an environment variable
  const token = Buffer.from(`${username}:${password}`).toString("base64"); // Encode the credentials to Base64

  // ðŸ‘‰ You can execute the custom logic here ðŸ‘ˆ

  const response = await fetch("https://your-store.saleor.cloud/graphql", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${token}`, // Using the Basic Auth header to authenticate the Saleor API
    },
    body: JSON.stringify({
      query: `
        // Read the query from the request body
      `,
    }),
  });

  res.status(200).json(data);
};
```

#### Step 4: Update the Next.js application to use the proxy

Our last step will be to update the Next.js application to use the proxy server instead of calling the Saleor API directly:

```jsx
async function getProducts() {
  // highlight-next-line
  const response = await fetch("/api/saleor", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    // ...
  });
  // ...
}
```

#### Further considerations

This is a simple example of how you can use a proxy server to obscure the Saleor API behind a basic auth. In a real-world scenario, you would most likely use a GraphQL client to fetch the data from the Saleor API. In that case, the effort to introduce the proxy server without modifying too much of the client code could be substantial.
