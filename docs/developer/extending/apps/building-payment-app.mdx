---
title: How to Build a Payment App
---

## Overview

In this tutorial, you will learn how to create a basic Payment App with [Transactions API](developer/extending/webhooks/synchronous-events/transaction.mdx).

:::note

We will be integrating with a fictional **Dummy Payment Gateway**. The behavior of Dummy Payment Gateway will mimic a real payment gateway, but it will not actually process any payments.

:::

### Prerequisites

- Basic understanding of [Saleor Apps](developer/extending/apps/overview.mdx)
- `node >=18.17.0 <=20`
- `pnpm >=9`

### What is a Payment App

Payment App is [a Saleor App](developer/extending/apps/overview.mdx) that implements a common interface for integrating with payment providers. Given that each payment provider comes with its unique payment flow, Saleor must provide an API flexible enough to accommodate all of them. That was the key principle behind the [Transactions API](developer/extending/webhooks/synchronous-events/transaction.mdx).

In this tutorial, we won't be covering all the API methods, but rather focus on the bare minimum required to build a Dummy Payment App. Keep in mind that a flow for integrating a real payment provider might be more complex.

:::info

If you need a reference point for integrating with an actual payment provider, you can check out the following examples:

- [Example Stripe App](https://github.com/saleor/saleor-app-payment-stripe)
- [Example Authorize.net App](https://github.com/saleor/saleor-app-payment-authorize.net)
- [Example Klarna App](https://github.com/saleor/saleor-app-payment-klarna)

:::

The centrepiece of any Payment App are [the synchronous webhooks](developer/extending/webhooks/synchronous-events/overview). This feature allows Saleor to suspend the resolution of an API call until a response from the app is received in the correct format. Saleor can then pass that response as a result of the API call. We will be looking at what webhooks we need to implement in [the next section](#webhooks).

### What is a Transaction

A transaction is an attempt to pay for an order. It is represented by a list of payment events. These events have their `status` field which expresses different stages of the payment process.

### Dummy Payment Gateway Flow

Payment Apps are meant to produce transactions. There are several webhooks that result in the creation of the transaction. The choice of the webhook depends on the payment flow that the payment provider implements.

For this tutorial, we will assume that the Dummy Payment Gateway implements the following flow:

1. Initiate the payment process (e.g., proceed to the payment page).
2. Ask for payment confirmation (e.g., redirect the user to the 3D Secure page).
3. Charge the payment on the 3D Secure page.
4. Redirect the user to the result (success or failure) page.

## Modeling the Transaction Flow

### Transaction Events

:::tip

Before starting any Payment App implementation, think of the transaction events you want to capture and how the app should transition between them. This will help you to choose the right webhooks and mutations.

:::

The first step in building our Payment App does not involve any code. To avoid further rework, we need to understand the transaction flow that we want to model. The end goal is to have a list of events produced by the app and their corresponding webhooks.

Let's extract two important details from the [Dummy Payment Gateway flow](#dummy-payment-gateway-flow):

- We want to successfully charge the payment.
- We can't charge the payment without the user's confirmation (3D Secure).

That means the app can't go straight to the `CHARGE_SUCCESS` / `CHARGE_FAILURE` event status. Before that, the user needs to confirm the payment. This step will be represented by the `CHARGE_ACTION_REQUIRED` event status.

Now, we can assign Saleor transaction event statuses to steps of the [Dummy Payment Gateway flow](#dummy-payment-gateway-flow):

| Step                                    | Status                                                                                                                              | Description                                                 |
| --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| 1. Initiate the payment process         | ---                                                                                                                                 | ---                                                         |
| 2. Confirm the payment via 3D Secure    | [`CHARGE_ACTION_REQUIRED`](api-reference/payments/enums/transaction-event-type-enum#transactioneventtypeenumcharge_action_required) | The payment requires additional action to be completed.     |
| 3. Charge the payment                   | ---                                                                                                                                 | ---                                                         |
| 3.1 Charge successful                   | [`CHARGE_SUCCESS`](api-reference/payments/enums/transaction-event-type-enum#transactioneventtypeenumcharge_success)                 | The payment was successful.                                 |
| 3.2 Charge failed                       | [`CHARGE_FAILURE`](api-reference/payments/enums/transaction-event-type-enum#transactioneventtypeenumcharge_failure)                 | The payment failed, for example, due to insufficient funds. |
| 4. Redirect the user to the result page | ---                                                                                                                                 | ---                                                         |

### Webhooks

Since we know what transaction events we want to capture, we can now choose the right webhooks to implement.

When exploring the [Transaction Events](developer/extending/webhooks/synchronous-events/transaction.mdx) documentation, you may notice that there are two webhooks that can result in the `CHARGE_SUCCESS` event: [`TRANSACTION_CHARGE_REQUESTED`](developer/extending/webhooks/synchronous-events/transaction.mdx#transaction-charge) and [`TRANSACTION_INITIALIZE_SESSION`](developer/extending/webhooks/synchronous-events/transaction.mdx#transaction-initialize-session).

There are two reasons for why **we are not going** with the `TRANSACTION_CHARGE_REQUESTED` webhook:

1. It is designed for the staff users to manually charge the payment. Since we want a checkout user (possibly unauthenticated) to be able to pay for the order, it is not a good fit.
2. It does not allow to return the `CHARGE_ACTION_REQUIRED` event status.

That leaves us with the `TRANSACTION_INITIALIZE_SESSION` webhook. It is triggered on the [`transactionInitializeSession`](api-reference/payments/mutations/transaction-initialize.mdx) mutation which can be used without any permissions. It can emit the `CHARGE_ACTION_REQUIRED` event status, as required.

When `TRANSACTION_INITIALIZE_SESSION` returns the `CHARGE_ACTION_REQUIRED`, the app needs to have a way of processing the additional action. Based on the result of that operation, we will either transition to the `CHARGE_SUCCESS` or `CHARGE_FAILURE` event status. This is where the second webhook is needed: [`TRANSACTION_PROCESS_SESSION`](developer/extending/webhooks/synchronous-events/transaction.mdx#process-transaction-session).

:::warning

The `TRANSACTION_PROCESS_SESSION` webhook will only be called if `TRANSACTION_INITIALIZE_SESSION` returns the `CHARGE_ACTION_REQUIRED` event status.

:::

Here is the list of webhooks and their corresponding transaction event statuses:

- `TRANSACTION_INITIALIZE_SESSION` -> `CHARGE_ACTION_REQUIRED`
- `TRANSACTION_PROCESS_SESSION` -> `CHARGE_SUCCESS` / `CHARGE_FAILURE`

Now that we know the webhooks we will be implementing, we can finally start coding.

## Creating a Saleor App from Template

Any app with server-side capabilities can be considered a Saleor App if it matches the requirements described in the [App Requirements](developer/extending/apps/architecture/app-requirements) document. Thanks to the [App Template](developer/extending/apps/developing-apps/app-template.mdx), we won't be checking all the boxes manually.

[`saleor-app-template`](https://github.com/saleor/saleor-app-template) is your Next.js starting point for building a Saleor App. It comes with all the necessary scaffolding to get you started. We will explore its features in the next sections of the tutorial. For now, let's clone the template and boot up our app:

```bash
git clone https://github.com/saleor/saleor-app-template.git
```

Then, navigate to the app directory and install the dependencies:

```bash
pnpm install
```

Finally, start the app:

```bash
pnpm dev
```

## Implementing the First Webhook

### App Manifest

Our first step will be visiting the `src/pages/api/manifest.ts` directory, where the App Manifest lives.

:::info

[App Manifest](developer/extending/apps/architecture/manifest.mdx) is the source of truth for all the app-related metadata, including its webhooks. The `/manifest` API route is called by Saleor during the app installation to provide all the necessary information about the app.

:::

The `webhooks` array of the App Manifest should be filled with the webhook manifests:

```ts
import { createManifestHandler } from "@saleor/app-sdk/handlers/next";
import { AppManifest } from "@saleor/app-sdk/types";

export default createManifestHandler({
  async manifestFactory({ appBaseUrl, request }) {
    // ...

    const manifest: AppManifest = {
      name: "Dummy Payment App",
      // ...
      webhooks: [], // ðŸ‘ˆ provide webhook manifests here
      // ...
    };
  },
});
```

Luckily, we don't need to do that manually.

[Saleor App SDK](developer/extending/apps/developing-apps/app-sdk/overview.mdx), a package included in the template, already provides helper classes for generating the webhooks: `SaleorSyncWebhook` and `SaleorAsyncWebhook`. These webhook instances have the `getWebhookManifest` method, which we can use to generate the webhook manifest.

### Declaring `SaleorSyncWebhook` Instance

In this step, we will be implementing a handler for our first webhook: `TRANSACTION_INITIALIZE_SESSION`.

Let's start by creating a new file in the `src/pages/api/webhooks` directory called `transaction-initialize-session.ts`. Then, initialize the `SaleorSyncWebhook` instance (since `TRANSACTION_INITIALIZE_SESSION` is a synchronous webhook):

```ts
import { SaleorAsyncWebhook } from "@saleor/app-sdk/handlers/next";
import { saleorApp } from "../../../saleor-app";

export const transactionInitializeSessionWebhook =
  new SaleorSyncWebhook<unknown /* TODO: Add the payload type */>({
    name: "Transaction Initialize Session",
    webhookPath: "api/webhooks/transaction-initialize-session",
    event: "TRANSACTION_INITIALIZE_SESSION",
    apl: saleorApp.apl,
    query: "", // TODO: Add the subscription query
  });
```

Let's go through all the constructor parameters of the `SaleorSyncWebhook` class:

- `name` - The name of the webhook. It will be used during the webhook registration process.
- `webhookPath` - The path to the webhook. It will be used to create the webhook URL.
  `event` - The [synchronous webhook event](api-reference/webhooks/enums/webhook-event-type-sync-enum.mdx#values) that the handler will be listening to.
- `apl` - The reference to the app's [APL](developer/extending/apps/developing-apps/app-sdk/apl). Saleor App Template exports it from `src/saleor-app.ts`.
- `query` - The query needed to generate the [subscription webhook payload](developer/extending/webhooks/subscription-webhook-payloads.mdx). It is currently empty because we don't have our subscription query yet.
- `unknown` generic attribute - The type of the payload that the webhook will receive. Since we don't have the subscription query yet, we don't know what the payload will look like.

### Building the Subscription Query

With Subscription Webhook Payload, you can define the shape of the payload that the webhook will receive. [GraphQL Code Generator](https://the-guild.dev/graphql/codegen) and the Saleor App SDK makes sure that the payload is correctly typed.

Let's define a subscription query for the `TRANSACTION_INITIALIZE_SESSION` handler:

```ts
import { gql } from "urql";

// ðŸ’¡ We suggest keeping the payload in a fragment. It is easier this way to retrieve individual fields from the subscription.
const TransactionInitializeSessionPayload = gql`
  fragment TransactionInitializeSessionPayload on TransactionInitializeSession {
    action {
      amount
      currency
      actionType
    }
  }
`;

const TransactionInitializeSessionSubscription = gql`
  # Payload fragment must be included in the root query
  ${TransactionInitializeSessionPayload}
  subscription TransactionInitializeSession {
    event {
      ...TransactionInitializeSessionPayload
    }
  }
`;
```

:::warning

Remember that adding a new field to the subscription query requires re-registering the webhook in Saleor API. You can read more about this behavior in [How to Update App Webhooks](developer/extending/apps/updating-app-webhooks.mdx).

:::

Then, let's run the following command to generate the types:

```bash
pnpm generate
```

When the command finishes, you should be able to import the type for the declared subscription query. With those two pieces, you can now update the `SaleorSyncWebhook` instance:

```ts
import { SaleorSyncWebhook } from "@saleor/app-sdk/handlers/next";
import { saleorApp } from "../../../saleor-app";
import { TransactionInitializeSessionPayloadFragment } from "../../../../generated/graphql";

export const transactionInitializeSessionWebhook =
  new SaleorSyncWebhook<TransactionInitializeSessionPayloadFragment /* ðŸ’¾ Updated with the payload type */>(
    {
      name: "Transaction Initialize Session",
      webhookPath: "api/webhooks/transaction-initialize-session",
      event: "TRANSACTION_INITIALIZE_SESSION",
      apl: saleorApp.apl,
      query: TransactionInitializeSessionSubscription, // ðŸ’¾ Updated with the subscription query
    }
  );
```

### Creating the Webhook Handler

The last step is to create the webhook handler. The handler is a function that will be called when the webhook is triggered. `saleor-app-sdk` handler is a decorated Next.js API ([pages](https://nextjs.org/docs/pages)) route handler. The extra bit is the Saleor context that is passed to the handler.

Let's extend our `transaction-initialize-session.ts` file with the handler boilerplate:

```ts
export default transactionInitializeSessionWebhook.createHandler(
  (req, res, ctx) => {
    const { payload, event, baseUrl, authData } = ctx;

    // TODO: Implement the handler

    return res.status(200).end();
  }
);
```

The `ctx` object contains the following properties:

- `payload` - The type-safe payload received from the webhook.
- `event` - Name of the event that triggered the webhook.
- `baseUrl` - The base URL of the app. If you need to register the app or webhook in an externak service, you can use this URL.
- `authData` - The [authentication data](developer/extending/apps/developing-apps/app-sdk/apl#authdata) passed from Saleor to the app. Among other things, it contains the `token` that can be used to query Saleor API.

## Testing the Webhook

TODO

## Implementing Transaction Process Session

TODO
