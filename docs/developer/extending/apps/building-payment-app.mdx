---
title: How to Build a Payment App
---

## Overview

In this tutorial, you will learn how to create a basic Payment App with [Transactions API](developer/extending/webhooks/synchronous-events/transaction.mdx).

:::note

We will be integrating with a fictional **Dummy Payment Gateway**. The Dummy Payment Gateway will mimic a real payment gateway but not actually process any payments.

:::

### Prerequisites

- Basic understanding of [Saleor Apps](developer/extending/apps/overview.mdx)
- `node >=18.17.0 <=20`
- `pnpm >=9`

### What is a Payment App

Payment App is [a Saleor App](developer/extending/apps/overview.mdx) that implements a standard payment interface. It allows Saleor to recognize the app as a payment provider and delegate the payment process to it.

That interface consists of [synchronous webhooks](developer/extending/webhooks/synchronous-events/overview.mdx). This feature allows Saleor to suspend the resolution of an API call until Saleor receives a response from the app in the correct format. Saleor can then pass that response as a result of the API call. We will look at what webhooks we must implement in [the "Webhooks" section](#webhooks).

Given that each payment service comes with its unique payment flow, Saleor must provide an API flexible enough to accommodate all of them. That was the key principle behind the [Transactions API](developer/extending/webhooks/synchronous-events/transaction.mdx), which we will be using for processing the payments.

Our simple, fictional payment gateway won't make us cover the entire API surface. Keep in mind that in case of integrating with a real payment provider, you will need to implement more webhooks and mutations.

:::info

If you need a reference point for integrating with real payment providers, you can check out the following examples:

- [Example Stripe App](https://github.com/saleor/saleor-app-payment-stripe)
- [Example Authorize.net App](https://github.com/saleor/saleor-app-payment-authorize.net)
- [Example Klarna App](https://github.com/saleor/saleor-app-payment-klarna)

:::

### What is a Transaction

A transaction represents a payment event that happened in Order or Checkout. These events include actions like charging a payment, authorizing or refunding it. You can see the full list of events in the [`TransactionEventTypeEnum`](api-reference/payments/enums/transaction-event-type-enum.mdx).

Besides the events, a transaction also contains the payment information, like the amount and currency. Transactions can be created and managed using the [Transactions API](developer/extending/webhooks/synchronous-events/transaction.mdx).

### Dummy Payment Gateway Flow

For this tutorial, we will assume that the Dummy Payment Gateway we will be integrating with implements the following flow:

Dummy Payment Gateway offers a drop-in payment UI that returns a token when the user starts the payment. The token should be used to confirm the payment on the backend.

1. Initiate the payment process in the drop-in.
2. Ask for payment confirmation (e.g., redirect the user to the 3D Secure page).
3. Charge the payment on the 3D Secure page.
4. Redirect the user to the result (success or failure) page.

## Modeling the Transaction Flow

### Transaction Events

:::tip

Before starting any Payment App implementation, consider the transaction events you want to capture and how the app should transition between them. This will help you choose the right webhooks and mutations.

:::

The first step in building our Payment App does not involve any code. To avoid further rework, we need to understand the transaction flow we want to model. The goal is to have a list of events produced by the app and their corresponding webhooks.

Let's extract two crucial details from the [Dummy Payment Gateway flow](#dummy-payment-gateway-flow):

- We want to charge the payment successfully.
- We can't charge the payment without the user's confirmation (3D Secure).

That means the app can't immediately return the `CHARGE_SUCCESS` / `CHARGE_FAILURE` event status. Before it does that, the user needs to confirm the payment. The `CHARGE_ACTION_REQUIRED` event status will represent this step.

Now, we can assign Saleor transaction event statuses to steps of the [Dummy Payment Gateway flow](#dummy-payment-gateway-flow):

| Step                                           | Status                                                                                                                                  | Description                                                                                                        |
| ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| 1. Initiate the payment process in the drop-in | ---                                                                                                                                     | ---                                                                                                                |
| 2. Confirm the payment via 3D Secure           | [`CHARGE_ACTION_REQUIRED`](api-reference/payments/enums/transaction-event-type-enum.mdx#transactioneventtypeenumcharge_action_required) | The payment requires additional action to be completed. **The drop-in token is needed to initialize the payment.** |
| 3. Charge the payment                          | ---                                                                                                                                     | ---                                                                                                                |
| 3.1 Charge successful                          | [`CHARGE_SUCCESS`](api-reference/payments/enums/transaction-event-type-enum.mdx#transactioneventtypeenumcharge_success)                 | The payment was successful.                                                                                        |
| 3.2 Charge failed                              | [`CHARGE_FAILURE`](api-reference/payments/enums/transaction-event-type-enum.mdx#transactioneventtypeenumcharge_failure)                 | The payment failed, for example, due to insufficient funds.                                                        |
| 4. Redirect the user to the result page        | ---                                                                                                                                     | ---                                                                                                                |

### Webhooks

Since we know what transaction events we want to capture, we can now choose the right webhooks to implement.

When exploring the [Transaction Events](developer/extending/webhooks/synchronous-events/transaction.mdx) documentation, you may notice that two webhooks can result in the `CHARGE_SUCCESS` event: [`TRANSACTION_CHARGE_REQUESTED`](developer/extending/webhooks/synchronous-events/transaction.mdx#transaction-charge) and [`TRANSACTION_INITIALIZE_SESSION`](developer/extending/webhooks/synchronous-events/transaction.mdx#request-4).

There are two reasons for why **we are not going** with the `TRANSACTION_CHARGE_REQUESTED` webhook:

1. It is designed for the staff users to charge the payment manually. Since we want a checkout user (possibly unauthenticated) to be able to pay for the order, it is not a good fit.
2. It does not allow the return of the `CHARGE_ACTION_REQUIRED` event status.

That leaves us with the `TRANSACTION_INITIALIZE_SESSION` webhook. It is triggered on the [`transactionInitialize`](api-reference/payments/mutations/transaction-initialize.mdx) mutation which can be used without any permissions. It can emit the `CHARGE_ACTION_REQUIRED` event status, as required.

When `TRANSACTION_INITIALIZE_SESSION` returns `CHARGE_ACTION_REQUIRED`, the app must execute this additional action. Depending on the outcome, we want the status to transition to either `CHARGE_SUCCESS` or `CHARGE_FAILURE`. The additional [`TRANSACTION_PROCESS_SESSION`](developer/extending/webhooks/synchronous-events/transaction.mdx#process-transaction-session) webhook will be responsible for this transition.

Here is the list of webhooks and their corresponding transaction event statuses:

- `TRANSACTION_INITIALIZE_SESSION` -> `CHARGE_ACTION_REQUIRED`
- `TRANSACTION_PROCESS_SESSION` -> `CHARGE_SUCCESS` / `CHARGE_FAILURE`

And the sequence diagram of the transaction flow:

```mermaid
sequenceDiagram
    participant Storefront as Storefront
    participant Saleor as Saleor
    participant App as Dummy Payment App
    Storefront->>Saleor: transactionInitialize
    Saleor->>App: TRANSACTION_INITIALIZE_SESSION
    App-->>Saleor: { result: CHARGE_ACTION_REQUIRED }
    Saleor->>Storefront: { type: CHARGE_ACTION_REQUIRED, ... }
    Storefront->>Saleor: transactionProcess
    Saleor->>App: TRANSACTION_PROCESS_SESSION
    App-->>Saleor: {result: CHARGE_SUCCESS / CHARGE_FAILURE }
    Saleor->>Storefront: { type: CHARGE_SUCCESS / CHARGE_FAILURE, ... }
```

Now that we know the webhooks we will implement, we can finally start coding.

## Creating a Saleor App from Template

Any app with server-side capabilities can be considered a Saleor App if it matches the requirements described in the [App Requirements](developer/extending/apps/architecture/app-requirements.mdx) document. Thanks to the [App Template](developer/extending/apps/developing-apps/app-template.mdx), we won't have to manually check all the boxes.

[`saleor-app-template`](https://github.com/saleor/saleor-app-template) is your Next.js starting point for building a Saleor App. It comes with all the necessary scaffolding to get you started. We will explore its features in the following sections of the tutorial. For now, let's clone the template and boot up our app:

```bash
git clone https://github.com/saleor/saleor-app-template.git
```

Then, navigate to the app directory and install the dependencies:

```bash
pnpm install
```

Finally, start the app:

```bash
pnpm dev
```

## Installing the App

To verify that the app is running correctly, we must install it in Saleor. To do that, we need to expose our local development environment to the internet via a tunneling service. If you don't have experience with tunneling, you can follow the [Tunneling Apps](developer/extending/apps/developing-with-tunnels.mdx) guide.

## Implementing Transaction Initialize Session

### App Manifest

Our first step will be visiting the `src/pages/api/manifest.ts` directory, where the App Manifest lives.

:::info

[App Manifest](developer/extending/apps/architecture/manifest.mdx) is the source of truth for all the app-related metadata, including its webhooks. Saleor calls the `/manifest` API route during the app installation to provide all the necessary information about the app.

:::

The `webhooks` array of the App Manifest should be filled with the webhook manifests:

```ts
import { createManifestHandler } from "@saleor/app-sdk/handlers/next";
import { AppManifest } from "@saleor/app-sdk/types";

export default createManifestHandler({
  async manifestFactory({ appBaseUrl, request }) {
    // ...
    const manifest: AppManifest = {
      name: "Dummy Payment App",
      webhooks: [], // 👈 provide webhook manifests here
      // ...
    };
  },
});
```

Luckily, we don't need to do that manually.

[Saleor App SDK](developer/extending/apps/developing-apps/app-sdk/overview.mdx), a package included in the template, already provides helper classes for generating the webhooks: `SaleorSyncWebhook` and `SaleorAsyncWebhook`. Webhook instances created from these classes have the `getWebhookManifest` method, which we can use to generate the webhook manifest.

### Declaring `SaleorSyncWebhook` Instance

In this step, we begin implementing a handler for our first webhook: `TRANSACTION_INITIALIZE_SESSION`.

We first need a new file in the `src/pages/api/webhooks` directory, called `transaction-initialize-session.ts`. Then, initialize the `SaleorSyncWebhook` instance (since `TRANSACTION_INITIALIZE_SESSION` is a synchronous webhook):

```ts
import { SaleorAsyncWebhook } from "@saleor/app-sdk/handlers/next";
import { saleorApp } from "../../../saleor-app";

export const transactionInitializeSessionWebhook =
  new SaleorSyncWebhook<unknown /* TODO: Add the payload type */>({
    name: "Transaction Initialize Session",
    webhookPath: "api/webhooks/transaction-initialize-session",
    event: "TRANSACTION_INITIALIZE_SESSION",
    apl: saleorApp.apl,
    query: "", // TODO: Add the subscription query
  });
```

Let's go through all the constructor parameters of the `SaleorSyncWebhook` class:

- `name` - The name of the webhook. It will be used during the webhook registration process.
- `webhookPath` - The path to the webhook.
  `event` - The [synchronous webhook event](api-reference/webhooks/enums/webhook-event-type-sync-enum.mdx#values) that the handler will be listening to.
- `apl` - The reference to the app's [APL](developer/extending/apps/developing-apps/app-sdk/apl.mdx). Saleor App Template exports it from `src/saleor-app.ts`.
- `query` - The query needed to generate the [subscription webhook payload](developer/extending/webhooks/subscription-webhook-payloads.mdx). It is currently empty because we still need to declare our subscription query.
- `unknown` generic attribute - The type of webhook payload the app will receive. Since we don't have the subscription query yet, it is `unknown`.

### Defining the Subscription Query

The next step will be filling that empty `query` attribute with an actual subscription query.

With [subscription webhook payloads](developer/extending/webhooks/subscription-webhook-payloads.mdx), you can define the shape of the payload the webhook will receive. [GraphQL Code Generator](https://the-guild.dev/graphql/codegen) and the Saleor App SDK ensure the payload is correctly typed.]

#### The `data` Field

Besides our generic payment-related fields, there is one field we are especially interested in: the `data` field.

There are no requirements for the content of the `data` field, as long as it is a valid JSON object. We can use it to pass any custom information that the payment provider requires.

In our case, we will use it to pass the token received from the drop-in. In the ["Calling the `transactionInitialize` Mutation"](#calling-the-transactioninitialize-mutation) section, we will provide the token as the mutation variable. In the app, we have to extract it from the payload.

#### The Subscription Query

With that knowledge, let's define a subscription query for the `TRANSACTION_INITIALIZE_SESSION` handler:

:::info

In Saleor App Template, we use [urql](https://formidable.com/open-source/urql/) to write GraphQL queries. If you prefer a different client, you still should be able to follow along.

:::

```ts
import { gql } from "urql";

// 💡 We suggest keeping the payload in a fragment. It is easier to retrieve individual fields from the subscription this way.
const TransactionInitializeSessionPayload = gql`
  fragment TransactionInitializeSessionPayload on TransactionInitializeSession {
    action {
      amount
      currency
      actionType
    }
  }
`;

const TransactionInitializeSessionSubscription = gql`
  # Payload fragment must be included in the root query
  ${TransactionInitializeSessionPayload}
  subscription TransactionInitializeSession {
    event {
      ...TransactionInitializeSessionPayload
    }
  }
`;
```

Then, let's regenerate the types (the app initially generated them during the dependencies installation):

```bash
pnpm generate
```

When the command finishes, you should be able to import the type for the declared subscription query. With those two pieces, you can now update the `SaleorSyncWebhook` instance:

```ts
import { SaleorSyncWebhook } from "@saleor/app-sdk/handlers/next";
import { saleorApp } from "../../../saleor-app";
import { TransactionInitializeSessionPayloadFragment } from "../../../../generated/graphql";

export const transactionInitializeSessionWebhook =
  new SaleorSyncWebhook<TransactionInitializeSessionPayloadFragment /* 💾 Updated with the payload type */>(
    {
      name: "Transaction Initialize Session",
      webhookPath: "api/webhooks/transaction-initialize-session",
      event: "TRANSACTION_INITIALIZE_SESSION",
      apl: saleorApp.apl,
      query: TransactionInitializeSessionSubscription, // 💾 Updated with the subscription query
    }
  );
```

Now that we have the webhook instance, we can use it to populate the `webhooks` array in the App Manifest:

```ts
// src/pages/api/manifest.ts
import { createManifestHandler } from "@saleor/app-sdk/handlers/next";
import { AppManifest } from "@saleor/app-sdk/types";
import { transactionInitializeSessionWebhook } from "./webhooks/transaction-initialize-session";

export default createManifestHandler({
  async manifestFactory({ appBaseUrl }) {
    // ...
    const manifest: AppManifest = {
      name: "Dummy Payment App",
      webhooks: [
        transactionInitializeSessionWebhook.getWebhookManifest(appBaseUrl),
      ],
      // ...
    };
  },
});
```

:::warning

Remember that modifying an existing subscription query or adding a new webhook requires manual webhook update in Saleor API. The easiest way to do it is to reinstall the app. You can read more about this behavior in [How to Update App Webhooks](developer/extending/apps/updating-app-webhooks.mdx).

:::

### Creating the Webhook Handler

The last step is to create the webhook handler. The handler is a function that will be called when the webhook is triggered. `saleor-app-sdk` handler is a decorated Next.js API ([pages](https://nextjs.org/docs/pages)) route handler. The extra bit is the Saleor context that is passed to the handler.

Let's extend our `transaction-initialize-session.ts` file with the handler boilerplate:

```ts
export default transactionInitializeSessionWebhook.createHandler(
  (req, res, ctx) => {
    const { payload, event, baseUrl, authData } = ctx;

    // TODO: Implement the handler

    return res.status(200).end();
  }
);
```

The `ctx` object contains the following properties:

- `payload` - The type-safe payload received from the webhook.
- `event` - Name of the event that triggered the webhook.
- `baseUrl` - The base URL of the app. If you need to register the app or webhook in an external service, you can use this URL.
- `authData` - The [authentication data](developer/extending/apps/developing-apps/app-sdk/apl.mdx#authdata) passed from Saleor to the app. Among other things, it contains the `token` you can use to query Saleor API.

Since we are implementing the Dummy Payment Gateway, our handler logic will be basic. We will just log the payload and return the `CHARGE_ACTION_REQUIRED` event status. The only thing we need to remember is that the webhook response must adhere to the [webhook response format](developer/extending/webhooks/synchronous-events/transaction.mdx#response-4):

<!-- TODO: add notion of payload.data -->

:::info

Here is what a real-world `TRANSACTION_INITIALIZE_SESSION` webhook handler might do:

- Retrieve some kind of token from the `payload.data` to identify the payment.
- Transform the payload into a format expected by the payment provider.
- Call the payment provider API (to, for example, create a payment intent).
- Process the response from the payment provider and return it.

:::

```ts
export default transactionInitializeSessionWebhook.createHandler(
  (req, res, ctx) => {
    const { payload, event, baseUrl, authData } = ctx;

    console.log("Transaction Initialize Session payload:", payload);

    const randomPspReference = crypto.randomUUID(); // Generate a random PSP reference

    return res.status(200).json({
      result: "CHARGE_ACTION_REQUIRED",
      amount: payload.action.amount, // `payload` is typed thanks to the generated types
      pspReference: randomPspReference,
      //   TODO: CHECK IF OTHER FIELDS ARE NEEDED
    });
  }
);
```

By returning the `CHARGE_ACTION_REQUIRED` event status, we are informing Saleor that the payment requires additional action to be completed. We will perform this action in the next webhook handler.

Besides the `result` field, we also return the `amount` and `pspReference` fields. The `amount` is the amount of the transaction, and the `pspReference` is a unique identifier of the payment in the payment provider system. Since we are not integrating with a real payment provider, we generate a random `pspReference`.

### Calling the `transactionInitialize` Mutation

Assuming you installed the app in Saleor, we can finally try out our webhook handler. We can trigger the `TRANSACTION_INITIALIZE_SESSION` event by calling the `transactionInitialize` mutation from [GraphQL Playground](docs/api-usage/developer-tools.mdx#playground).

Here is what the mutation looks like:

```graphql
mutation TransactionInitialize($checkoutId: ID!, $paymentGateway: String!) {
  transactionInitialize(
    id: $checkoutId
    paymentGateway: { id: $paymentGateway }
  ) {
    transaction {
      id
    }
    transactionEvent {
      id
      type
    }
    errors {
      field
      message
      code
    }
  }
}
```

The mutation requires two variables: `checkoutId` and `paymentGateway`.

The `checkoutId` is the ID of the checkout that we want to pay for.

The `paymentGateway` is the ID of the payment gateway that we want to use. We can see what payment gateways are available for the checkout by requesting the `availablePaymentGateways` field on the `checkout` query:

```graphql
query GetCheckout($id: ID!) {
  checkout(id: $id) {
    availablePaymentGateways {
      id
      name
    }
  }
}
```

If we installed the app correctly, we should see the "Dummy Payment Gateway" in the list of available payment gateways. The `id` will be drawn from the App Manifest's `id` field.

If we have the `checkoutId` and `paymentGateway`, we can now call the `transactionInitialize` mutation. In the response, we should see the created transaction and the transaction event with the `CHARGE_ACTION_REQUIRED` type:

<!-- TODO: ADD REAL RESPONSE -->

```json
{
  "data": {
    "transactionInitialize": {
      "transaction": {
        "id": "UHJvamVjdFRy"
      },
      "transactionEvent": {
        "id": "VHJhbnNhY3Rpb25FdmVudDoz",
        "type": "CHARGE_ACTION_REQUIRED"
      },
      "errors": []
    }
  }
}
```

The app's console should also log the payload received from the webhook.

## Implementing Transaction Process Session

### Creating the Webhook Handler

:::warning

The `transactionProcess` mutation will only reach the app if the previous call to `TRANSACTION_INITIALIZE_SESSION` returned either `CHARGE_ACTION_REQUIRED` or `AUTHORIZE_ACTION_REQUIRED` event status.

:::

When successfully called, our first webhook handler returned the `CHARGE_ACTION_REQUIRED` event status. Now, we need to implement the second webhook handler, `TRANSACTION_PROCESS_SESSION`, to transition the status to either `CHARGE_SUCCESS` or `CHARGE_FAILURE`.

We will start by repeating the steps from the previous section. Let's create a new file in the `src/pages/api/webhooks` directory, called `transaction-process-session.ts`.

Then, declare the subscription query for the `TRANSACTION_PROCESS_SESSION` webhook:

```ts
import { TransactionProcessSessionPayloadFragment } from "../../../../generated/graphql"; // Import the generated payload type
import { gql } from "urql";

// 💡 Remember to regenerate the types after adding the new subscription query
const TransactionProcessSessionPayload = gql`
  fragment TransactionProcessSessionPayload on TransactionProcessSession {
    action {
      amount
      currency
      actionType
    }
  }
`;

const TransactionProcessSessionSubscription = gql`
  ${TransactionProcessSessionPayload}
  subscription TransactionProcessSession {
    event {
      ...TransactionProcessSessionPayload
    }
  }
`;
```

And then, create the `SaleorSyncWebhook` instance, as well as the webhook handler:

```ts
import { SaleorSyncWebhook } from "@saleor/app-sdk/handlers/next";
import { saleorApp } from "../../../saleor-app";
// ...

export const transactionProcessSessionWebhook =
  new SaleorSyncWebhook<TransactionProcessSessionPayloadFragment>({
    name: "Transaction Process Session",
    webhookPath: "api/webhooks/transaction-process-session",
    event: "TRANSACTION_PROCESS_SESSION",
    apl: saleorApp.apl,
    query: TransactionProcessSessionSubscription,
  });

export default transactionProcessSessionWebhook.createHandler(
  (req, res, ctx) => {
    const { payload, event, baseUrl, authData } = ctx;

    console.log("Transaction Process Session payload:", payload);

    return res.status(200).json({
      result: "CHARGE_SUCCESS",
      amount: payload.action.amount,
      pspReference: crypto.randomUUID(),
    });
  }
);
```

:::info

Here is what a real-world `TRANSACTION_PROCESS_SESSION` webhook handler might do:

- Call the payment provider API to check the payment status.
- Process the response from the payment provider and return the `CHARGE_SUCCESS` or `CHARGE_FAILURE` event status.

:::

If the handler would perform a logic that can fail, we should try to catch the error and return the `CHARGE_FAILURE` event status:

```ts
export default transactionProcessSessionWebhook.createHandler(
  (req, res, ctx) => {
    const { payload, event, baseUrl, authData } = ctx;

    console.log("Transaction Process Session payload:", payload);

    try {
      doSomethingThatCanFail(); // This function can throw an error

      return res.status(200).json({
        result: "CHARGE_SUCCESS",
        amount: payload.action.amount,
        pspReference: crypto.randomUUID(),
      });
    } catch (error) {
      return res.status(200).json({
        result: "CHARGE_FAILURE",
        amount: payload.action.amount,
        pspReference: crypto.randomUUID(),
      });
    }
  }
);
```

The last step is to update the App Manifest with the new webhook:

```ts
// src/pages/api/manifest.ts
import { createManifestHandler } from "@saleor/app-sdk/handlers/next";
import { AppManifest } from "@saleor/app-sdk/types";
import { transactionInitializeSessionWebhook } from "./webhooks/transaction-initialize-session";
// highlight-next-line
import { transactionProcessSessionWebhook } from "./webhooks/transaction-process-session";

export default createManifestHandler({
  async manifestFactory({ appBaseUrl }) {
    // ...
    const manifest: AppManifest = {
      name: "Dummy Payment App",
      webhooks: [
        transactionInitializeSessionWebhook.getWebhookManifest(appBaseUrl),
        // highlight-next-line
        transactionProcessSessionWebhook.getWebhookManifest(appBaseUrl),
      ],
      // ...
    };
  },
});
```

Once again, remember to update the app's webhooks or reinstall the app in Saleor. Otherwise, the new webhook handler won't be called.

### Calling the `transactionProcess` Mutation

To test the `TRANSACTION_PROCESS_SESSION` webhook, we need to call the `transactionProcess` mutation. The mutation requires the `transactionId` variable, which is the ID of the transaction we want to process. That will be the `id` field from the `transaction` object returned by the `transactionInitialize` mutation.

Here is what the mutation looks like:

```graphql
mutation TransactionProcess($transactionId: ID!) {
  transactionProcess(id: $transactionId) {
    transaction {
      id
    }
    transactionEvent {
      id
      type
    }
    errors {
      field
      message
      code
    }
  }
}
```

In response, we should receive the processed transaction and the corresponding transaction event with the `CHARGE_SUCCESS` type:

```json
{
  "data": {
    "transactionProcess": {
      "transaction": {
        "id": "UHJvamVjdFRy"
      },
      "transactionEvent": {
        "id": "VHJhbnNhY3Rpb25FdmVudDoz",
        "type": "CHARGE_SUCCESS"
      },
      "errors": []
    }
  }
}
```

## Next steps

- Payment gateway initialize
- Storing payment methods
- Service → Saleor `transactionEventReport` webhook
